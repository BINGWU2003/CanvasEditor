# NOTE

## 数据结构
数据结构的设计，类似于`DeltaSet`，最终呈现的数据结构形式是扁平化的，但是在`Core`中需要设计`State`来管理树形结构，因为要设计`Undo/Redo`的功能，在不全量存储快照的情况下就意味着必须设计原子化的`Op`，因为想实现的功能有组合这个能力，所以最终实现的形式实际上是树形的结构，而我希望的结构是扁平化的，因为树形结构查找起来比较费劲，需要实现的`Op`类型也会变多，我希望能尽量减少`Op`的类型并且能够做到`History`，所以最终定下的数据结构是`DeltaSet`作为存储，通过`State`来管理整个编辑器状态。

## History
原子化的`Op`已经设计好了，所以在设计`History`模块时就不需要全量保存快照了，但是如果每个操作都需要并入`History Stack`的话可能并不是很好，通常都是有`N`个`Op`的一并`Undo/Redo`，所以这个模块应该有一个定时器，如果在`N`毫秒秒内没有新的`Op`加入的话就将`Op`并入`History Stack`，但是当时我在思考一个问题，如果这`N`毫秒内用户进行了`Undo`操作应该怎么办，后来想想实际上很简单，此时只需要清除定时器，将暂存的`Op[]`立即放置于`Redo Stack`即可。

## 绘制
任何元素都是矩形，数据结构也是据此设计抽象出来的，在绘制的时候分为两层`Canvas`重叠的方式，内层的`Canvas`是用来绘制具体图形的，这里预计需要实现增量更新，而外层的`Canvas`是用来绘制中间状态的，例如选中图形、多选、调整图形位置/大小等，在这里是会全量刷新的，并且后边可能会在这里绘制标尺。在实现交互的过程中我遇到了一个比较棘手的问题，因为不存在`DOM`，所有的操作都是需要根据位置信息来计算的，比如选中图形后调整大小的点就需要在选中状态下并且点击的位置恰好是那几个点外加一定的偏移量，然后再根据`MouseMove`事件来调整图形大小，而实际上在这里的交互会非常多，包括多选、拖拽框选、`Hover`效果，都是根据`MouseDown`、`MouseMove`、`MouseUp`三个事件完成的，所以如何管理状态以及绘制`UI`交互就是个比较麻烦的问题，在这里我只能想到根据不同的状态来携带不同的`Payload`，进而绘制交互。

## 绘制状态
在实现绘制的时候，我一直在考虑应该如何实现这个能力，因为上边也说了这里是没有`DOM`的，所以最开始的时候我通过`MouseDown`、`MouseMove`、`MouseUp`实现了一个非常混乱的状态管理，完全是基于事件的触发然后执行相关副作用从而调用`Mask`的方法进行重新绘制。再后来我觉得这样的代码根本没有办法维护，所以改动了一下，将我所需要的状态全部都存储到一个`Store`中，通过我自定义的事件管理来通知状态的改变，最终通过状态改变的类型来严格控制将要绘制的内容，也算是将相关的逻辑抽象了一层，只不过在这里相当于是我维护了大量的状态，而且这些状态是相互关联的，所以会有很多的`if/else`去处理不同类型的状态改变，而且因为很多方法会比较复杂，传递了多层，导致状态管理虽然比之前好了一些可以明确知道状态是因为哪里导致变化的，但是实际上依旧不容易维护。最终我又思考了一下，决定在绘图这里实现类似于`DOM`的能力，因为我想实现的能力似乎本质上就是`DOM`与事件的关联，而`DOM`结构是一种非常成熟的设计了，这其中有一些很棒的点子，例如`DOM`的事件流，我不需要扁平化地调整每个`Node`的事件，而是只需要保证事件是从`ROOT`节点起始，最终又在`ROOT`上结束即可，并且整个树形结构以及状态是靠用户利用`DOM`的`API`来实现的，我们管理之需要处理`ROOT`就好了，这样就会很方便，下个阶段的状态管理是准备用这种方式来实现的。
